<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="../hljs/styles/tomorrow-night-eighties.css">
    <script type="text/javascript" src="../hljs/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

</head>

<body>
    <h1>动态规划</h1>
    <div>
        <h3>状态转移方程</h3>
        <p>
            <br>知道A, 知道B, 得出C, AB转移成C！
            <br>最优子结构：母问题最优解包含其子问题的最优解， -> 最优子结构
            <br>子问题重叠：子问题本质上和母问题一样的，只是参数不同 -> 子问题重叠
            动态规划程序设计：解决最优化的一种途径、方法，<s>特殊算法</s>
        </p>
    </div>
    <h3 id="模式">动态规划算法一般模式</h3>
    <ul>
        <li><strong>划分阶段</strong>：按照问题的特征，分成若干阶段</li>
        <li><strong>确定状态和状态变量</strong>：问题发展状态，所处情况</li>
        <li><strong>确定决策并写出状态转移方程</strong>：相邻状态之间关系确定决策</li>
        <li><strong>寻找边界条件</strong>：递推式边界条件</li>
    </ul>
    <h2>背包问题</h2>
    <h3>动态规划分析</h3>
    <ol>
        <li><strong>划分阶段</strong>以物品个数为阶段</li>
        <li><strong>确定状态和状态变量</strong></li>
        <li><strong>确定决策并写出状态转移方程</strong></li>
        <li><strong>寻找边界条件</strong></li>
    </ol>
    <h4>表格</h4>
    <img src="biaoge.jpg" alt="动态规划表格" title="动态规划表格">
    <h3>代码</h3>
    <pre>
        <code>
            /*
输入格式：
m n
w1 c1
w2 c2
w3 c3
......
wm-1 cn-1
wm cn
*/
// 01背包
#include<iostream>                                              //头文件
using namespace std;                                            //命名空间
int w[200];                                                     //重量
int c[200];                                                     //价值
int f[200][200];                                                //最优解
int main(){                                                     //面函数
    int m=0,n=0;                                                //背包容量，物品个数
    cin>>m>>n;                                                  //输入背包容量，物品个数
    for(int i=1;i<=n;i++)                                       //循环输入物品
        cin>>w[i]>>c[i];                                        //输入重量，价值
    for(int i=1;i<=n;i++){                                      //动态规划
        for(int j=1;j<=m;j++){                                  //遍历
            if(j>=w[i]){                                        //判断当前物品是否可以放进包中
                f[i][j] = max(f[i-1][j-w[i]]+c[i], f[i-1][j]);  //决策，是否要放入包中，最优解
            }else{                                              //否则
                f[i][j] = f[i-1][j];                            //直接拉下来
            }                                                   //继续
        }                                                       //继续
    }                                                           //继续
    cout&lt;&lt;f[n][m];                                              //输出最优解
    return 0;                                                   //结束
}   //

//决策部分伪代码
/*
如果包包能装得下好东西，那么：
    f[i][j] = 选择最大的(包包腾地然后放好东西后的价值, 原来的价值)
否则：
    继续
*/
        </code>
    </pre>

</body>

</html>